<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- SEO & PWA Improvements -->
    <meta name="description" content="Poker Reveal X: Quantum Hand Analysis simulates revealing poker hands with a high-tech hacker interface.">
    <meta name="theme-color" content="#0f172a">
    <link rel="manifest" href="manifest.json">
    <link rel="icon" href="favicon.ico" type="image/x-icon">
    
    <title>Poker Reveal X: Quantum Enhanced</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Font Preloading -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet" as="style">
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    
    <style>
        :root {
            --font-orbitron: 'Orbitron', sans-serif;
            --font-inter: 'Inter', sans-serif;
            --glow-cyan: 0 0 15px rgba(56, 189, 248, 0.4), 0 0 5px rgba(56, 189, 248, 0.6);
            --glow-green-cta: 0 0 15px rgba(34, 197, 94, 0.5), 0 0 5px rgba(34, 197, 94, 0.7);
        }
        body {
            font-family: var(--font-inter);
            background-color: #020617;
            background-image: 
                radial-gradient(circle at 25% 25%, rgba(14, 165, 233, 0.1) 0%, transparent 40%),
                radial-gradient(circle at 75% 75%, rgba(59, 130, 246, 0.1) 0%, transparent 40%);
            color: #e5e7eb;
            overflow-x: hidden;
        }
        .font-orbitron { font-family: var(--font-orbitron); }
        .glass-container {
            background: rgba(17, 24, 39, 0.6);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(55, 65, 81, 0.3);
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        .custom-select {
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%239ca3af' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");
            background-position: right 0.5rem center;
            background-repeat: no-repeat;
            background-size: 1.5em 1.5em;
            -webkit-appearance: none; -moz-appearance: none; appearance: none;
        }
        .console-scrollbar::-webkit-scrollbar { width: 4px; }
        .console-scrollbar::-webkit-scrollbar-track { background: #1f2937; }
        .console-scrollbar::-webkit-scrollbar-thumb { background: #38bdf8; border-radius: 2px; }

        /* Animated Gradient Header */
        .animated-gradient-header {
            background: linear-gradient(270deg, #1e3a8a, #38bdf8, #10b981, #3b82f6);
            background-size: 800% 800%;
            animation: gradientBG 15s ease infinite;
        }
        @keyframes gradientBG {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        /* Card Styles & Flip Animation */
        .card-container {
            perspective: 1000px;
            width: clamp(55px, 8vw, 75px);
            height: clamp(77px, 11.2vw, 105px);
            position: relative;
        }
        .card-flipper {
            position: relative; width: 100%; height: 100%;
            transition: transform 0.7s cubic-bezier(0.25, 1, 0.5, 1);
            transform-style: preserve-3d;
        }
        .card-container.flipped .card-flipper { transform: rotateY(180deg); }
        .card-face {
            position: absolute; width: 100%; height: 100%;
            -webkit-backface-visibility: hidden; backface-visibility: hidden;
            border-radius: clamp(4px, 1vw, 6px);
        }
        .card-back {
            background: radial-gradient(circle, #2563eb, #1d4ed8);
            border: 2px solid #3b82f6; display: flex;
            align-items: center; justify-content: center;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.5);
        }
        .card-back::after {
            content: 'X'; font-family: var(--font-orbitron);
            font-size: clamp(24px, 5vw, 40px);
            color: rgba(255,255,255,0.4);
            text-shadow: 0 0 10px rgba(255,255,255,0.5);
        }
        .card-front {
            transform: rotateY(180deg); background-color: #f9fafb;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3); overflow: hidden;
        }
        .card-front-content {
            display: flex; flex-direction: column; justify-content: space-between;
            width: 100%; height: 100%; padding: clamp(2px, 0.8vw, 5px);
            font-weight: 600; line-height: 1;
        }
        .card-front .rank { font-size: clamp(0.8rem, 2.5vw, 1.2rem); }
        .card-front .suit { font-size: clamp(0.6rem, 2vw, 1rem); }
        .card-front .center-suit { font-size: clamp(1.5rem, 4vw, 2.5rem); text-align: center; line-height: 0.8; }
        .card-front .red { color: #ef4444; }
        .card-front .black { color: #111827; }
        .card-bottom-rank { transform: rotate(180deg); }
        
        /* Modal & Animation */
        @keyframes fadeIn { from { opacity: 0; transform: scale(0.95); } to { opacity: 1; transform: scale(1); } }
        .modal-animated { animation: fadeIn 0.3s ease-out forwards; }
        
        /* Console Typewriter */
        .typewriter-cursor {
            display: inline-block; width: 8px; height: 1em;
            background-color: #38bdf8; animation: blink 1s step-end infinite;
            vertical-align: middle;
        }
        @keyframes blink { 50% { opacity: 0; } }
        
        .log-success { color: #4ade80; }
        .log-error { color: #f87171; }
        .log-warning { color: #facc15; }
        .log-partial { color: #60a5fa; }
        
        /* Winner Highlight */
        .winner-highlight { box-shadow: 0 0 25px rgba(74, 222, 128, 0.8), 0 0 10px rgba(255, 255, 255, 0.8); transform: scale(1.05); border-color: #4ade80 !important; }

        /* Auto Mode Toggle Switch */
        .toggle-switch { position: relative; display: inline-block; width: 50px; height: 28px; }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #4b5563; transition: .4s; border-radius: 28px; }
        .slider:before { position: absolute; content: ""; height: 20px; width: 20px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: #22c55e; }
        input:checked + .slider:before { transform: translateX(22px); }
    </style>
</head>
<body class="flex items-center justify-center min-h-screen p-2 sm:p-4">

    <!-- Main App Container -->
    <main id="main-app" class="glass-container w-full max-w-7xl rounded-2xl overflow-hidden hidden">
        <header class="p-4 sm:p-6 border-b border-gray-700/50 text-center relative animated-gradient-header">
            <h1 class="text-xl sm:text-2xl md:text-4xl font-orbitron font-black text-white tracking-wider uppercase" style="text-shadow: 0 2px 5px rgba(0,0,0,0.5);">
                Poker Reveal <span class="text-cyan-200">X: Quantum</span>
            </h1>
            <p class="text-gray-200 text-xs sm:text-sm mt-1" data-i18n="appSubtitle">Análise de Mão por Emaranhamento Quântico</p>
            <div id="hands-remaining-display" class="absolute top-3 left-5 text-sm font-mono bg-yellow-500/10 text-yellow-400 px-3 py-1 rounded-full border border-yellow-500/30"></div>
            <a href="https://www.revealpoker.top/" target="_blank" id="acquire-app-btn" class="absolute top-4 right-5 cta-btn bg-green-600 hover:bg-green-500 text-white font-bold py-2 px-4 rounded-lg transition transform hover:scale-105" style="box-shadow: var(--glow-green-cta);">
                <span data-i18n="acquireAppButton">Adquirir App</span>
            </a>
        </header>

        <section id="game-mode-screen" class="p-4 sm:p-8 space-y-6 hidden">
             <h2 class="text-xl font-bold text-center text-cyan-300 mb-3 font-orbitron" data-i18n="modeSelectTitle">SELECIONE A MODALIDADE</h2>
             <div class="grid grid-cols-2 md:grid-cols-3 gap-4">
                <button data-mode="nlh" class="mode-btn bg-sky-600 hover:bg-sky-500 p-6 rounded-lg text-center transition transform hover:-translate-y-1">
                    <p class="font-bold text-lg">NLH</p>
                    <p class="text-xs text-sky-200" data-i18n="modeNLH">No-Limit Hold'em</p>
                </button>
                <button data-mode="plo" class="mode-btn bg-purple-600 hover:bg-purple-500 p-6 rounded-lg text-center transition transform hover:-translate-y-1">
                    <p class="font-bold text-lg">PLO</p>
                    <p class="text-xs text-purple-200" data-i18n="modePLO">Pot-Limit Omaha</p>
                </button>
                <button data-mode="plo5" class="mode-btn bg-gray-700 p-6 rounded-lg text-center cursor-not-allowed opacity-50">
                     <p class="font-bold text-lg">PLO5</p>
                     <p class="text-xs text-yellow-400" data-i18n="modePLO5">Em Manutenção</p>
                </button>
             </div>
        </section>

        <section id="setup-screen" class="p-4 sm:p-8 space-y-6 hidden">
            <div class="flex items-center mb-4">
                <button id="back-to-mode-select" class="text-cyan-400 hover:text-cyan-200 mr-4">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path></svg>
                </button>
                <h2 class="text-xl font-bold text-center text-cyan-300 font-orbitron" data-i18n="setupTitle">CONFIGURAR JOGO</h2>
            </div>
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                <div>
                    <label for="platform-select" class="block text-sm font-medium text-gray-400 mb-2" data-i18n="platformLabel">Plataforma</label>
                    <select id="platform-select" class="w-full bg-gray-900/50 border border-gray-600 rounded-md px-3 py-2 text-gray-200 focus:ring-2 focus:ring-cyan-500 focus:border-cyan-500 transition custom-select">
                        <option value="" disabled selected data-i18n="platformPlaceholder">Selecione a Plataforma</option>
                        <option value="pppoker">PPPOKER</option><option value="xpoker">XPOKER</option><option value="clubgg">CLUBGG</option>
                    </select>
                </div>
                <div>
                    <label for="table-id" class="block text-sm font-medium text-gray-400 mb-2" data-i18n="tableIdLabel">ID da Mesa / Clube</label>
                    <input type="text" id="table-id" class="w-full bg-gray-900/50 border border-gray-600 rounded-md px-3 py-2 text-gray-200 focus:ring-2 focus:ring-cyan-500 focus:border-cyan-500 transition placeholder-gray-500" data-i18n-placeholder="tableIdPlaceholder" placeholder="ex: 12345678">
                </div>
                <div>
                    <label for="num-players" class="block text-sm font-medium text-gray-400 mb-2" data-i18n="opponentsLabel">Oponentes</label>
                    <select id="num-players" class="w-full bg-gray-900/50 border border-gray-600 rounded-md px-3 py-2 text-gray-200 focus:ring-2 focus:ring-cyan-500 focus:border-cyan-500 transition custom-select">
                        <option>2</option> <option>3</option> <option>4</option> <option selected>5</option> <option>6</option> <option>7</option> <option>8</option><option>9</option>
                    </select>
                </div>
            </div>
            <div class="flex items-center justify-between">
                <div class="flex items-center space-x-3">
                    <label for="auto-mode-toggle" class="text-sm font-medium text-gray-300" data-i18n="autoModeLabel">Modo Automático (10s)</label>
                    <label class="toggle-switch">
                        <input type="checkbox" id="auto-mode-toggle">
                        <span class="slider"></span>
                    </label>
                </div>
                <button id="reveal-btn" class="bg-cyan-600 hover:bg-cyan-500 text-white font-bold py-3 px-6 rounded-lg transition-all duration-300 shadow-lg shadow-cyan-500/20 flex items-center justify-center space-x-2 text-lg transform hover:scale-105 active:scale-100">
                    <span data-i18n="engageButton">Engajar Link Quântico</span>
                </button>
            </div>
        </section>

        <section id="results-screen" class="p-4 sm:p-6 border-t border-gray-700/50 hidden">
            <!-- Community Cards -->
            <div class="mb-6">
                <h2 class="text-lg font-bold text-center text-cyan-300 mb-3 font-orbitron" data-i18n="communityCardsTitle">CARTAS COMUNITÁRIAS</h2>
                <div id="community-cards-display" class="flex justify-center items-center gap-1 sm:gap-2 h-[110px]"></div>
            </div>

            <!-- Opponent Hands -->
            <div id="cards-display" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-5 gap-4"></div>

            <!-- Console, History & Actions -->
            <div class="mt-6 grid grid-cols-1 lg:grid-cols-3 gap-4">
                <div id="console-container" class="lg:col-span-2 bg-black/50 rounded-lg p-4 h-56 font-mono text-xs console-scrollbar overflow-y-auto">
                    <div id="console-output"></div>
                    <span id="console-cursor" class="typewriter-cursor hidden"></span>
                </div>
                <div class="flex flex-col space-y-4">
                    <div id="action-buttons" class="flex flex-col justify-center items-center gap-4"></div>
                    <div id="hand-history-container" class="bg-black/30 rounded-lg p-3 h-full">
                        <h3 class="font-orbitron text-sm text-cyan-300 mb-2" data-i18n="handHistoryTitle">Histórico de Mãos</h3>
                        <ul id="hand-history-list" class="text-xs space-y-1 font-mono"></ul>
                    </div>
                </div>
            </div>
             <!-- Deck State -->
            <div id="deck-state-container" class="mt-4 bg-black/30 rounded-lg p-3 hidden">
                <h3 class="font-orbitron text-sm text-cyan-300 mb-2" data-i18n="deckStateTitle">Estado do Baralho Restaurado</h3>
                <p id="deck-state-output" class="text-xs font-mono text-gray-400 break-all"></p>
            </div>
        </section>
    </main>
    
    <!-- Modals -->
    <div id="access-modal" class="fixed inset-0 bg-slate-900/80 flex items-center justify-center p-4 z-50">
        <div class="glass-container w-full max-w-sm rounded-2xl p-8 text-center modal-animated">
            <h2 class="text-2xl font-orbitron font-bold text-cyan-300 mb-2" data-i18n="authTitle">AUTENTICAÇÃO</h2>
            <div id="auth-subtitle" class="text-gray-400 mb-6 text-sm"></div>
            <input type="text" id="access-code-input" class="w-full bg-gray-900/70 border border-gray-600 rounded-md px-3 py-3 text-gray-200 focus:ring-2 focus:ring-cyan-500 focus:border-cyan-500 transition placeholder-gray-500 text-center uppercase tracking-widest" data-i18n-placeholder="authPlaceholder" placeholder="INSERIR CHAVE">
            <button id="submit-code-btn" class="mt-6 w-full bg-cyan-600 hover:bg-cyan-500 text-white font-bold py-3 px-6 rounded-lg transition transform hover:scale-105 active:scale-100" data-i18n="authButton">Autenticar</button>
        </div>
    </div>
    <div id="custom-alert" class="fixed inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center p-4 hidden z-50">
        <div class="glass-container w-full max-w-sm rounded-lg shadow-xl p-6 text-center border border-yellow-500 modal-animated">
            <p id="custom-alert-message" class="text-white mb-4">Message goes here.</p>
            <button id="custom-alert-close" class="bg-yellow-500 hover:bg-yellow-400 text-gray-900 font-bold py-2 px-6 rounded-lg transition" data-i18n="okButton">OK</button>
        </div>
    </div>
    <div id="limit-reached-modal" class="fixed inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center p-4 hidden z-50">
        <div class="glass-container w-full max-w-sm rounded-lg shadow-xl p-8 text-center border border-red-500 modal-animated">
            <h2 class="text-xl font-orbitron font-bold text-red-500 mb-2" data-i18n="limitTitle">SATURAÇÃO DO LINK</h2>
            <p class="text-white mb-6" data-i18n="limitSubtitle">Revelações quânticas esgotadas para esta chave.</p>
            <a id="acquire-key-link" href="#" target="_blank" class="contact-btn bg-cyan-600 hover:bg-cyan-500 text-white font-bold py-2 px-4 rounded-lg">
                <span data-i18n="openTelegramButton">Abrir Telegram</span>
            </a>
        </div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // =======================================================
        // SECURITY THEATER & ANTI-DEBUG
        // =======================================================
        let devToolsDelayFactor = 1;
        document.addEventListener('contextmenu', event => event.preventDefault());
        document.onkeydown = function(e) {
            if (e.keyCode === 123 || (e.ctrlKey && e.shiftKey && (e.keyCode === 'I'.charCodeAt(0) || e.keyCode === 'J'.charCodeAt(0) || e.keyCode === 'C'.charCodeAt(0))) || (e.ctrlKey && e.keyCode === 'U'.charCodeAt(0))) {
                return false;
            }
        };
        const detectDevTools = () => {
            const threshold = 160;
            const check = () => {
                const startTime = performance.now();
                debugger;
                const endTime = performance.now();
                if (endTime - startTime > threshold) {
                    if (devToolsDelayFactor === 1) { // Only log once
                        console.log("%cPARE!", "color:red;font-size:30px;font-family:Orbitron;");
                        console.log("%cFerramentas de desenvolvedor detectadas. As operações serão retardadas.", "color:yellow;font-size:14px;font-family:Inter;");
                    }
                    devToolsDelayFactor = 5; // Increase delay for operations
                }
            };
            setInterval(check, 1000);
        };
        detectDevTools();

        // --- I18N (TRANSLATIONS) ---
        const translations = {
            pt: {
                revealsLabel: "REVELAÇÕES", acquireAppButton: "Adquirir App", appSubtitle: "Análise de Mão por Emaranhamento Quântico",
                modeSelectTitle: "SELECIONE A MODALIDADE", modeNLH: "No-Limit Hold'em", modePLO: "Pot-Limit Omaha", modePLO5: "Em Manutenção",
                setupTitle: "CONFIGURAR JOGO", platformLabel: "Plataforma", platformPlaceholder: "Selecione a Plataforma",
                tableIdLabel: "ID da Mesa / Clube", tableIdPlaceholder: "ex: 12345678", opponentsLabel: "Oponentes",
                engageButton: "Engajar Link Quântico", communityCardsTitle: "CARTAS COMUNITÁRIAS", authTitle: "AUTENTICAÇÃO",
                authSubtitle: "Insira a chave de ativação para estabelecer o link quântico.", authPlaceholder: "INSERIR CHAVE", authButton: "Autenticar",
                okButton: "OK", limitTitle: "SATURAÇÃO DO LINK", limitSubtitle: "Revelações quânticas esgotadas para esta chave.",
                openTelegramButton: "Abrir Telegram", acquireKeyMessage: "Quero obter um novo código para acessar o Reveal Poker X.",
                invalidCode: "Chave inválida ou expirada.", usedCode: "Esta chave já foi totalmente utilizada.",
                selectPlatform: "Por favor, selecione uma plataforma.", enterTableId: "Por favor, insira o ID da mesa.",
                waitHand: "Por favor, aguarde a mão atual terminar.", newHandButton: "Nova Mão", newGameButton: "Novo Jogo",
                autoModeLabel: "Modo Automático (10s)", handHistoryTitle: "Histórico de Mãos", deckStateTitle: "Estado do Baralho Restaurado",
                consoleInitiating: "Iniciando link quântico com {platform}...",
                consoleProbingHash: "Sondando pipeline de entropia: {hash}...",
                consoleAttemptHash: "Tentativa #{attempt} com seed={seed}: Hash={hash}",
                consolePartialMatch: "colisão parcial ({percent}%)",
                consoleCollision: "COLISÃO ENCONTRADA",
                consoleLinkSuccess: '<span class="log-success">Link Quântico Estabilizado. Acesso Concedido.</span>',
                consoleValidatingSig: "Validando assinatura...",
                consoleSigOK: '<span class="log-success">OK</span>',
                consoleBypassingSSL: "Contornando camada de soquete seguro...",
                consoleBypassingDone: '<span class="log-success">concluído</span>',
                consoleExtractingEntropy: "Extraindo entropia pré-flop...",
                consoleEntropyDone: '<span class="log-success">concluído</span>',
                consoleCapturedEntropy: "Entropia Capturada: {entropy}",
                consoleReadingStates: "Lendo estados quânticos pré-flop...",
                consoleRevealing: "Revelando {stage}...",
                consoleFailurePreFlop: '<span class="log-error">FALHA NA DECRIPTAÇÃO:</span> Fluxo de dados pré-flop instável. Não foi possível obter as cartas comunitárias.',
                consoleFailurePostFlop: '<span class="log-error">FALHA NA DECRIPTAÇÃO:</span> Não foi possível obter os dados do Turn/River do hash: <span class="text-yellow-400">{hash}</span>',
                handHistoryEntry: "Mão #{num}: Vencedor Pos {winner} ({hand})",
            }
        };
        // FIXED: Restored the i18n object with the init function
        const i18n = {
            lang: 'pt',
            init: function() {
                document.documentElement.lang = this.lang;
                this.translateAll();
            },
            get: function(key, r = {}) { let t = translations['pt'][key] || key; for (const p in r) { t = t.replace(`{${p}}`, r[p]); } return t; },
            translateAll: function() { document.querySelectorAll('[data-i18n]').forEach(el => { const key = el.dataset.i18n; if(el.tagName === 'INPUT' || el.tagName === 'TEXTAREA') el.placeholder = this.get(key); else el.innerHTML = this.get(key); }); }
        };
        

        // --- DOM ELEMENTS ---
        const allDomElements = {
            mainApp: document.getElementById('main-app'), accessModal: document.getElementById('access-modal'),
            gameModeScreen: document.getElementById('game-mode-screen'), setupScreen: document.getElementById('setup-screen'),
            resultsScreen: document.getElementById('results-screen'), accessCodeInput: document.getElementById('access-code-input'),
            submitCodeBtn: document.getElementById('submit-code-btn'), authSubtitle: document.getElementById('auth-subtitle'),
            revealBtn: document.getElementById('reveal-btn'), platformSelect: document.getElementById('platform-select'),
            tableIdInput: document.getElementById('table-id'), numPlayersSelect: document.getElementById('num-players'),
            consoleOutput: document.getElementById('console-output'), consoleCursor: document.getElementById('console-cursor'),
            cardsDisplay: document.getElementById('cards-display'), communityCardsDisplay: document.getElementById('community-cards-display'),
            actionButtons: document.getElementById('action-buttons'), handsRemainingDisplay: document.getElementById('hands-remaining-display'),
            customAlert: document.getElementById('custom-alert'), customAlertMessage: document.getElementById('custom-alert-message'),
            customAlertClose: document.getElementById('custom-alert-close'), limitReachedModal: document.getElementById('limit-reached-modal'),
            acquireKeyLink: document.getElementById('acquire-key-link'), backToModeSelectBtn: document.getElementById('back-to-mode-select'),
            autoModeToggle: document.getElementById('auto-mode-toggle'), handHistoryList: document.getElementById('hand-history-list'),
            deckStateContainer: document.getElementById('deck-state-container'), deckStateOutput: document.getElementById('deck-state-output')
        };
        
        // --- DATA & STATE ---
        const SUITS = { '♠': 'spades', '♥': 'hearts', '♦': 'diamonds', '♣': 'clubs' };
        const RANKS = ['2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'A'];
        const RANK_VALUES = {'2':2, '3':3, '4':4, '5':5, '6':6, '7':7, '8':8, '9':9, 'T':10, 'J':11, 'Q':12, 'K':13, 'A':14};
        const OBFUSCATED_CODES = { 'UVVBTlRVTTIwMjU=': 5, 'WFJFVkFBTFBSTw==': 10, 'RUxJVEVIQUNL': 2, 'SEFDS1RFU1Q=': 1 };
        let VALID_CODES = {};
        for (const key in OBFUSCATED_CODES) { VALID_CODES[atob(key)] = OBFUSCATED_CODES[key]; }

        let deck = [], players = [], communityCards = [], handHistory = [];
        let gameState = 'IDLE', currentGameMode = null, isIncognito = false, handCounter = 0;
        let soundEnabled = false, synths = {}, autoModeInterval = null;

        // --- SOUND ENGINE ---
        const setupSounds = () => { if (soundEnabled) return; Tone.start(); synths.click = new Tone.Synth({oscillator:{type:'sine'},envelope:{attack:0.005,decay:0.1,sustain:0.3,release:1}}).toDestination(); synths.flip = new Tone.NoiseSynth({noise:{type:'white'},envelope:{attack:0.005,decay:0.05,sustain:0}}).toDestination(); synths.win = new Tone.PolySynth(Tone.Synth,{oscillator:{type:"fatsawtooth"},envelope:{attack:0.01,decay:0.2,sustain:0.2,release:0.2}}).toDestination(); synths.error = new Tone.Synth({oscillator:{type:'triangle'},envelope:{attack:0.01,decay:0.2,sustain:0,release:0.1}}).toDestination(); synths.hashTick = new Tone.Synth({oscillator:{type:'square', frequency: 1200}, envelope:{attack:0.001,decay:0.05,sustain:0,release:0.01}}).toDestination(); synths.success = new Tone.Synth({oscillator:{type:'sine', frequency: 600}, envelope:{attack:0.01,decay:0.2,sustain:0.1,release:0.1}}).toDestination(); soundEnabled = true; };
        const playSound = (sound, note, time) => { if (soundEnabled && synths[sound]) synths[sound].triggerAttackRelease(note, "8n", time); };

        // --- HELPER FUNCTIONS ---
        const delay = ms => new Promise(res => setTimeout(res, ms * devToolsDelayFactor));
        const createDeck = () => Object.keys(SUITS).flatMap(suit => RANKS.map(rank => ({ suit, rank })));
        const shuffleDeck = () => { deck = createDeck(); for (let i = deck.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [deck[i], deck[j]] = [deck[j], deck[i]]; } };
        const generateHash = (len=16) => Array(len).fill(0).map(() => '0123456789abcdef'[Math.floor(Math.random()*16)]).join('');

        // --- UI & ALERT FUNCTIONS ---
        const showAlert = message => { playSound('error', 'C3'); allDomElements.customAlertMessage.textContent = message; allDomElements.customAlert.classList.remove('hidden'); };
        const updateHandsRemainingDisplay = () => { const max = parseInt(localStorage.getItem('pokerRevealMaxHands'), 10); const used = parseInt(localStorage.getItem('pokerRevealHandsUsed'), 10); if (!isNaN(max) && !isNaN(used)) { allDomElements.handsRemainingDisplay.textContent = `${i18n.get('revealsLabel')}: ${max - used}`; } };

        const createCardHTML = card => {
            let content = '';
            if (card) {
                const colorClass = (card.suit === '♥' || card.suit === '♦') ? 'red' : 'black';
                const rankSymbol = card.rank === 'T' ? '10' : card.rank;
                content = `<div class="card-front-content ${colorClass}"><div class="text-left"><div class="rank">${rankSymbol}</div><div class="suit">${card.suit}</div></div><div class="center-suit">${card.suit}</div><div class="text-right card-bottom-rank"><div class="rank">${rankSymbol}</div><div class="suit">${card.suit}</div></div></div>`;
            }
            return `<div class="card-container"><div class="card-flipper"><div class="card-face card-back"></div><div class="card-face card-front">${content}</div></div></div>`;
        };

        async function typeMessage(messageKey, replacements = {}, speed = 15) {
            const message = i18n.get(messageKey, replacements);
            const p = document.createElement('p');
            p.innerHTML = `<span class="text-cyan-400">&gt;</span> `;
            allDomElements.consoleOutput.appendChild(p);
            const textEl = document.createElement('span');
            p.appendChild(textEl);
            const tempDiv = document.createElement('div'); tempDiv.innerHTML = message;
            const nodes = Array.from(tempDiv.childNodes);
            for (const node of nodes) {
                if (node.nodeType === Node.TEXT_NODE) {
                    for (let char of node.textContent) { textEl.innerHTML += char; allDomElements.consoleOutput.scrollTop = allDomElements.consoleOutput.scrollHeight; await delay(speed + Math.random() * 10); }
                } else { textEl.appendChild(node.cloneNode(true)); }
            }
            allDomElements.consoleOutput.scrollTop = allDomElements.consoleOutput.scrollHeight;
        }

        // --- POKER HAND EVALUATION LOGIC ---
        function evaluateHand(cards, mode) {
            const handRanksI18n = { pt: { 10: "Royal Flush", 9: "Straight Flush", 8: "Quadra", 7: "Full House", 6: "Flush", 5: "Sequência", 4: "Trinca", 3: "Dois Pares", 2: "Um Par", 1: "Carta Alta" } };
            const k_combinations = (set, k) => { if (k > set.length || k <= 0) return []; if (k === set.length) return [set]; if (k === 1) return set.map(e => [e]); const combos = []; for (let i = 0; i < set.length - k + 1; i++) { const head = set.slice(i, i + 1); const tailcombos = k_combinations(set.slice(i + 1), k - 1); for (const tail of tailcombos) { combos.push(head.concat(tail)); } } return combos; };
            let combosToTest = [];
            if (mode === 'nlh') { combosToTest = k_combinations(cards, 5); } 
            else if (mode === 'plo') {
                const holeCards = cards.slice(0, 4); const boardCards = cards.slice(4);
                if (holeCards.length < 2 || boardCards.length < 3) return { rank: 0, name: "Mão Inválida", values: [] };
                const holeCombos = k_combinations(holeCards, 2); const boardCombos = k_combinations(boardCards, 3);
                for(const hc of holeCombos) { for (const bc of boardCombos) { combosToTest.push([...hc, ...bc]); } }
            }
            if (combosToTest.length === 0 && cards.length >= 5) { combosToTest = k_combinations(cards, 5); }
            let bestHand = { rank: 0, name: "Carta Alta", values: [] };
            for(const combo of combosToTest) {
                const ranks = combo.map(c => RANK_VALUES[c.rank]).sort((a, b) => b - a); const suits = combo.map(c => c.suit);
                const isFlush = new Set(suits).size === 1; const isStraight = ranks.every((r, i) => i === 0 || r === ranks[i-1] - 1) || (ranks[0] === 14 && ranks[1] === 5 && ranks[2] === 4 && ranks[3] === 3 && ranks[4] === 2);
                let currentRank = 0, currentValues = ranks;
                if (isStraight && isFlush) { currentRank = (ranks[0] === 14 && ranks[1] === 13) ? 10 : 9; if(currentRank === 9 && ranks[0]===14) currentValues = [5,4,3,2,1]; }
                else {
                    const rankCounts = ranks.reduce((acc, r) => { acc[r] = (acc[r] || 0) + 1; return acc; }, {});
                    const counts = Object.values(rankCounts).sort((a,b) => b-a); const mainCards = Object.keys(rankCounts).filter(r => rankCounts[r] >= 2).map(Number).sort((a,b)=>b-a);
                    if (counts[0] === 4) { currentRank = 8; currentValues = [mainCards[0], ...ranks.filter(r => r !== mainCards[0])]; }
                    else if (counts[0] === 3 && counts[1] === 2) { currentRank = 7; currentValues = [mainCards.find(c => rankCounts[c] === 3), mainCards.find(c => rankCounts[c] === 2)]; }
                    else if (isFlush) { currentRank = 6; }
                    else if (isStraight) { currentRank = 5; if(ranks[0]===14) currentValues = [5,4,3,2,1]; }
                    else if (counts[0] === 3) { currentRank = 4; currentValues = [mainCards[0], ...ranks.filter(r => r !== mainCards[0])]; }
                    else if (counts[0] === 2 && counts[1] === 2) { currentRank = 3; currentValues = [mainCards[0], mainCards[1], ...ranks.filter(r => !mainCards.includes(r))]; }
                    else if (counts[0] === 2) { currentRank = 2; currentValues = [mainCards[0], ...ranks.filter(r => r !== mainCards[0])]; }
                    else { currentRank = 1; }
                }
                const compareHighCards = (a, b) => { for (let i = 0; i < a.length; i++) { if (a[i] !== b[i]) return a[i] - b[i]; } return 0; };
                if (currentRank > bestHand.rank || (currentRank === bestHand.rank && compareHighCards(currentValues, bestHand.values) > 0)) {
                    bestHand = { rank: currentRank, name: handRanksI18n['pt'][currentRank], values: currentValues };
                }
            }
            return bestHand;
        }

        // --- CORE LOGIC ---
        function checkAccess() {
            const code = localStorage.getItem('pokerRevealAccessCode');
            const maxHands = parseInt(localStorage.getItem('pokerRevealMaxHands'), 10);
            const handsUsed = parseInt(localStorage.getItem('pokerRevealHandsUsed'), 10);
            if (!localStorage.getItem('pokerRevealVisited')) { allDomElements.authSubtitle.innerHTML = i18n.get('authSubtitle'); localStorage.setItem('pokerRevealVisited', 'true'); } 
            else { allDomElements.authSubtitle.innerHTML = i18n.get('authSubtitle'); }
            if (code && !isNaN(maxHands) && !isNaN(handsUsed) && handsUsed < maxHands) {
                allDomElements.accessModal.classList.add('hidden'); allDomElements.mainApp.classList.remove('hidden');
                allDomElements.gameModeScreen.classList.remove('hidden'); updateHandsRemainingDisplay();
            } else { allDomElements.mainApp.classList.add('hidden'); allDomElements.accessModal.classList.remove('hidden'); }
        }

        function handleAccessCodeSubmit() {
            if (isIncognito) { showAlert("Modo anônimo detectado. Por favor, use uma janela normal do navegador."); return; }
            setupSounds(); playSound('click', 'C4');
            const code = allDomElements.accessCodeInput.value.trim().toUpperCase();
            const usedCodes = JSON.parse(localStorage.getItem('pokerRevealUsedCodes') || '[]');
            if (usedCodes.includes(code)) { showAlert(i18n.get('usedCode')); return; }
            if (VALID_CODES[code]) {
                localStorage.setItem('pokerRevealAccessCode', code); localStorage.setItem('pokerRevealMaxHands', VALID_CODES[code]);
                localStorage.setItem('pokerRevealHandsUsed', '0'); checkAccess();
            } else { showAlert(i18n.get('invalidCode')); }
        }
        
        function validateInputs() {
            if (allDomElements.platformSelect.value === "") { showAlert(i18n.get('selectPlatform')); return false; }
            if (allDomElements.tableIdInput.value === "") { showAlert(i18n.get('enterTableId')); return false; }
            return true;
        }

        async function simulateAdvancedHashCrack() {
            const targetHash = generateHash(16);
            const seed = generateHash(6);
            await typeMessage('consoleProbingHash', { hash: targetHash.substring(0,12) + '...' });
            await delay(500);
            let found = false;
            for (let i = 1; i <= 8; i++) {
                if (found) break;
                const currentHash = generateHash(16);
                let matchPercent = 0;
                for(let j=0; j<targetHash.length; j++) { if(targetHash[j] === currentHash[j]) matchPercent++; }
                matchPercent = Math.floor((matchPercent / targetHash.length) * 100);
                let status = (i > 3 && Math.random() < 0.25) ? (found = true, ` - <span class="log-success">${i18n.get('consoleCollision')}</span>`) : (matchPercent > 30 ? ` - <span class="log-partial">${i18n.get('consolePartialMatch', {percent: matchPercent})}</span>` : " - sem correspondência");
                await typeMessage('consoleAttemptHash', { attempt: i, seed: seed, hash: currentHash.substring(0,12) + '...' + status });
                playSound('hashTick', null, Tone.now() + i * 0.01);
                await delay(300 + Math.random() * 200);
            }
            if (!found) { await typeMessage('consoleAttemptHash', { attempt: 9, seed: seed, hash: targetHash.substring(0,12) + `... - <span class="log-success">${i18n.get('consoleCollision')}</span>` }); }
            playSound('success', 'C5');
        }

        async function handleReveal() {
            if (gameState !== 'IDLE' || !validateInputs()) return;
            const maxHands = parseInt(localStorage.getItem('pokerRevealMaxHands'), 10);
            if (parseInt(localStorage.getItem('pokerRevealHandsUsed'), 10) >= maxHands) {
                allDomElements.limitReachedModal.classList.remove('hidden');
                allDomElements.acquireKeyLink.href = `https://t.me/bedmalcon_temp?text=${encodeURIComponent(i18n.get('acquireKeyMessage'))}`;
                return;
            }

            gameState = 'REVEALING';
            allDomElements.revealBtn.disabled = true;
            allDomElements.setupScreen.classList.add('hidden');
            allDomElements.resultsScreen.classList.remove('hidden');
            resetBoard();
            
            allDomElements.consoleCursor.classList.remove('hidden');
            const platform = allDomElements.platformSelect.options[allDomElements.platformSelect.selectedIndex].text;
            await typeMessage('consoleInitiating', { platform: platform });
            await typeMessage('consoleCapturedEntropy', { entropy: `${generateHash(4)}-${generateHash(4)}-${generateHash(4)}` });
            await simulateAdvancedHashCrack();
            await typeMessage('consoleValidatingSig', {}, 5); await delay(300);
            allDomElements.consoleOutput.lastChild.innerHTML += ` <span class="log-success">${i18n.get('consoleSigOK')}</span>`;
            await typeMessage('consoleBypassingSSL', {}, 5); await delay(400);
            allDomElements.consoleOutput.lastChild.innerHTML += ` <span class="log-success">${i18n.get('consoleBypassingDone')}</span>`;
            await typeMessage('consoleExtractingEntropy', {}, 5); await delay(500);
            allDomElements.consoleOutput.lastChild.innerHTML += ` <span class="log-success">${i18n.get('consoleEntropyDone')}</span>`;
            await typeMessage('consoleLinkSuccess');
            allDomElements.consoleCursor.classList.add('hidden');
            
            processHandReveal();
        }

        function processHandReveal() {
            let handsUsed = parseInt(localStorage.getItem('pokerRevealHandsUsed'), 10) || 0;
            handsUsed++;
            localStorage.setItem('pokerRevealHandsUsed', handsUsed);
            updateHandsRemainingDisplay();
            const maxHands = parseInt(localStorage.getItem('pokerRevealMaxHands'), 10);
            if (handsUsed >= maxHands) {
                const code = localStorage.getItem('pokerRevealAccessCode'); let usedCodes = JSON.parse(localStorage.getItem('pokerRevealUsedCodes') || '[]');
                if (code && !usedCodes.includes(code)) { usedCodes.push(code); localStorage.setItem('pokerRevealUsedCodes', JSON.stringify(usedCodes)); }
            }
            dealAndDisplay();
        }

        function resetBoard() {
            allDomElements.cardsDisplay.innerHTML = ''; allDomElements.communityCardsDisplay.innerHTML = '';
            allDomElements.actionButtons.innerHTML = ''; allDomElements.consoleOutput.innerHTML = '';
            allDomElements.deckStateContainer.classList.add('hidden');
            players = []; communityCards = [];
        }

        async function dealAndDisplay() {
            shuffleDeck();
            handCounter++;
            const numOpponents = parseInt(allDomElements.numPlayersSelect.value, 10);
            const holeCardsCount = currentGameMode === 'plo' ? 4 : 2;

            for (let i = 0; i < numOpponents; i++) {
                players.push({ id: i, name: `Posição ${i + 1}`, hand: deck.splice(0, holeCardsCount), div: null });
            }
            deck.pop(); // burn
            communityCards = deck.splice(0, 5);

            players.forEach(player => {
                const playerDiv = document.createElement('div');
                playerDiv.className = 'p-3 flex flex-col items-center space-y-2 bg-slate-800/50 rounded-lg border border-gray-700/50 transition-all duration-500';
                let cardsHTML = player.hand.map(() => createCardHTML(null)).join('');
                playerDiv.innerHTML = `<div class="flex items-center gap-2 w-full"><div class="flex-shrink-0 w-6 h-6 rounded-full bg-cyan-800/50 flex items-center justify-center font-mono text-cyan-300 text-xs">${player.id + 1}</div><h3 class="font-bold text-gray-300 text-sm truncate">${player.name}</h3></div><div class="flex flex-wrap justify-center gap-1 player-hand">${cardsHTML}</div><div class="hand-rank-display text-cyan-200 text-xs h-4 font-medium"></div>`;
                allDomElements.cardsDisplay.appendChild(playerDiv);
                player.div = playerDiv;
            });

            await typeMessage('consoleReadingStates');
            await delay(1000);

            // Reveal hole cards
            const allCardElements = document.querySelectorAll('.player-hand .card-container');
            for (let i = 0; i < allCardElements.length; i++) {
                const container = allCardElements[i];
                const playerIndex = players.findIndex(p => p.div.contains(container));
                const cardIndex = Array.from(container.parentNode.children).indexOf(container);
                setTimeout(() => {
                    playSound('flip', null, Tone.now());
                    container.outerHTML = createCardHTML(players[playerIndex].hand[cardIndex]);
                    document.querySelectorAll('.player-hand .card-container')[i].classList.add('flipped');
                }, 80 * i);
            }
            await delay(allCardElements.length * 80 + 500);

            const outcomeRoll = Math.random();
            let revealScenario;
            if (outcomeRoll < 0.05) { revealScenario = 'FULL_REVEAL'; }
            else if (outcomeRoll < 0.35) { revealScenario = 'FLOP_ONLY'; }
            else { revealScenario = 'CARDS_ONLY'; }
            
            let revealedBoard = [];
            if (revealScenario === 'CARDS_ONLY') {
                await typeMessage('consoleFailurePreFlop');
            } else {
                revealedBoard.push(...communityCards.slice(0, 3));
                await revealCommunityStage('Flop', 0, 3);
                if (revealScenario === 'FLOP_ONLY') {
                    await delay(1000);
                    await typeMessage('consoleFailurePostFlop', { hash: generateHash() });
                } else { // FULL_REVEAL
                    await delay(1500);
                    revealedBoard.push(communityCards[3]);
                    await revealCommunityStage('Turn', 3, 1);
                    await delay(1500);
                    revealedBoard.push(communityCards[4]);
                    await revealCommunityStage('River', 4, 1);
                    await delay(1500);
                }
            }
            
            if(revealedBoard.length > 0) {
                evaluateAllHands(revealedBoard);
            }

            showActionButtons();
            gameState = 'FINISHED';
        }

        async function revealCommunityStage(stageName, start, count) {
            await typeMessage('consoleRevealing', { stage: stageName });
            for (let i = start; i < start + count; i++) {
                const cardElem = document.createElement('div');
                cardElem.innerHTML = createCardHTML(communityCards[i]);
                const cardContainer = cardElem.firstElementChild;
                allDomElements.communityCardsDisplay.appendChild(cardContainer);
                await delay(50);
                playSound('flip', null, Tone.now());
                cardContainer.classList.add('flipped');
                await delay(100);
            }
        }
        
        function evaluateAllHands(board) {
            let bestOverallHand = { rank: 0, values: [] };
            let winners = [];
            players.forEach(player => {
                const cardsToEval = [...player.hand, ...board];
                player.bestHand = evaluateHand(cardsToEval, currentGameMode);
                player.div.querySelector('.hand-rank-display').textContent = player.bestHand.name;
                
                const compare = (a, b) => { for (let i = 0; i < a.length; i++) { if (a[i] !== b[i]) return a[i] - b[i]; } return 0; };
                if (player.bestHand.rank > bestOverallHand.rank || (player.bestHand.rank === bestOverallHand.rank && compare(player.bestHand.values, bestOverallHand.values) > 0)) {
                    bestOverallHand = player.bestHand; winners = [player];
                } else if (player.bestHand.rank === bestOverallHand.rank && compare(player.bestHand.values, bestOverallHand.values) === 0) {
                    winners.push(player);
                }
            });
            winners.forEach(winner => {
                winner.div.classList.add('winner-highlight');
                playSound('win', 'C4', Tone.now());
            });

            updateHandHistory(winners);
            displayDeckState();
        }

        function showActionButtons() {
            allDomElements.actionButtons.innerHTML = `<button id="new-hand-btn" class="w-full sm:w-auto bg-blue-600 hover:bg-blue-500 text-white font-bold py-2 px-5 rounded-lg transition transform hover:scale-105">${i18n.get('newHandButton')}</button><button id="new-game-btn" class="w-full sm:w-auto bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-5 rounded-lg transition transform hover:scale-105">${i18n.get('newGameButton')}</button>`;
            document.getElementById('new-hand-btn').addEventListener('click', handleNewHandClick);
            document.getElementById('new-game-btn').addEventListener('click', resetGame);
        }

        function updateHandHistory(winners) {
            const winnerNames = winners.map(w => w.id + 1).join(', ');
            const handName = winners.length > 0 ? winners[0].bestHand.name : 'N/A';
            const entry = { num: handCounter, winner: winnerNames, hand: handName };
            handHistory.unshift(entry);
            if (handHistory.length > 5) handHistory.pop();

            allDomElements.handHistoryList.innerHTML = handHistory.map(h => `<li>${i18n.get('handHistoryEntry', h)}</li>`).join('');
        }

        function displayDeckState() {
            const deckString = deck.map(c => `${c.rank}${c.suit}`).join(', ');
            allDomElements.deckStateOutput.textContent = `[${deckString}]`;
            allDomElements.deckStateContainer.classList.remove('hidden');
        }

        function handleNewHandClick() {
            if (gameState === 'REVEALING') { showAlert(i18n.get('waitHand')); return; }
            playSound('click', 'C4'); gameState = 'IDLE'; handleReveal();
        }

        function resetGame() {
            playSound('click', 'C4'); gameState = 'IDLE';
            allDomElements.resultsScreen.classList.add('hidden');
            allDomElements.gameModeScreen.classList.remove('hidden');
            allDomElements.setupScreen.classList.add('hidden');
            allDomElements.revealBtn.disabled = false;
            allDomElements.tableIdInput.value = ''; allDomElements.platformSelect.value = '';
            handHistory = []; allDomElements.handHistoryList.innerHTML = ''; handCounter = 0;
            if (autoModeInterval) {
                clearInterval(autoModeInterval); autoModeInterval = null;
                allDomElements.autoModeToggle.checked = false;
            }
        }
        
        // --- EVENT LISTENERS ---
        allDomElements.submitCodeBtn.addEventListener('click', handleAccessCodeSubmit);
        allDomElements.accessCodeInput.addEventListener('keyup', (e) => { if (e.key === 'Enter') allDomElements.submitCodeBtn.click(); });
        allDomElements.customAlertClose.addEventListener('click', () => allDomElements.customAlert.classList.add('hidden'));
        allDomElements.revealBtn.addEventListener('click', handleReveal);
        
        allDomElements.gameModeScreen.addEventListener('click', e => {
            const button = e.target.closest('button[data-mode]'); if (!button || button.disabled) return;
            playSound('click', 'C4'); currentGameMode = button.dataset.mode;
            allDomElements.gameModeScreen.classList.add('hidden'); allDomElements.setupScreen.classList.remove('hidden');
        });
        
        allDomElements.backToModeSelectBtn.addEventListener('click', () => {
             playSound('click', 'C3'); allDomElements.setupScreen.classList.add('hidden');
             allDomElements.gameModeScreen.classList.remove('hidden');
        });

        allDomElements.autoModeToggle.addEventListener('change', (e) => {
            if (e.target.checked) {
                if (gameState !== 'IDLE') { e.target.checked = false; return; }
                handleNewHandClick();
                autoModeInterval = setInterval(handleNewHandClick, 10000);
            } else {
                if (autoModeInterval) { clearInterval(autoModeInterval); autoModeInterval = null; }
            }
        });
        
        // --- INITIALIZATION ---
        // Moved i18n.init() to after its definition
        i18n.init();
        
        (async () => {
            try {
                if (navigator.storage && navigator.storage.estimate) {
                    const { quota } = await navigator.storage.estimate();
                    if (quota < 120000000) isIncognito = true;
                }
            } catch (e) { isIncognito = true; }
            checkAccess();
        })();
    });
    </script>
</body>
</html>
